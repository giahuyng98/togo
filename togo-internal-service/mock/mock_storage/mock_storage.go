// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock_storage

import (
	"context"
	"sync"
	"time"
	"togo-internal-service/internal/model"
	"togo-internal-service/internal/storage"
)

// Ensure, that StorageMock does implement storage.Storage.
// If this is not the case, regenerate this file with moq.
var _ storage.Storage = &StorageMock{}

// StorageMock is a mock implementation of storage.Storage.
//
// 	func TestSomethingThatUsesStorage(t *testing.T) {
//
// 		// make and configure a mocked storage.Storage
// 		mockedStorage := &StorageMock{
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			CreateTaskFunc: func(ctx context.Context, task *model.Task) (*model.Task, error) {
// 				panic("mock out the CreateTask method")
// 			},
// 			GetTaskFunc: func(ctx context.Context, ID string) (*model.Task, error) {
// 				panic("mock out the GetTask method")
// 			},
// 			ListTaskFunc: func(ctx context.Context, userID string, date time.Time, limit int, offset int) ([]*model.Task, error) {
// 				panic("mock out the ListTask method")
// 			},
// 		}
//
// 		// use mockedStorage in code that requires storage.Storage
// 		// and then make assertions.
//
// 	}
type StorageMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CreateTaskFunc mocks the CreateTask method.
	CreateTaskFunc func(ctx context.Context, task *model.Task) (*model.Task, error)

	// GetTaskFunc mocks the GetTask method.
	GetTaskFunc func(ctx context.Context, ID string) (*model.Task, error)

	// ListTaskFunc mocks the ListTask method.
	ListTaskFunc func(ctx context.Context, userID string, date time.Time, limit int, offset int) ([]*model.Task, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CreateTask holds details about calls to the CreateTask method.
		CreateTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Task is the task argument value.
			Task *model.Task
		}
		// GetTask holds details about calls to the GetTask method.
		GetTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// ListTask holds details about calls to the ListTask method.
		ListTask []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// Date is the date argument value.
			Date time.Time
			// Limit is the limit argument value.
			Limit int
			// Offset is the offset argument value.
			Offset int
		}
	}
	lockClose      sync.RWMutex
	lockCreateTask sync.RWMutex
	lockGetTask    sync.RWMutex
	lockListTask   sync.RWMutex
}

// Close calls CloseFunc.
func (mock *StorageMock) Close() error {
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedStorage.CloseCalls())
func (mock *StorageMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CreateTask calls CreateTaskFunc.
func (mock *StorageMock) CreateTask(ctx context.Context, task *model.Task) (*model.Task, error) {
	callInfo := struct {
		Ctx  context.Context
		Task *model.Task
	}{
		Ctx:  ctx,
		Task: task,
	}
	mock.lockCreateTask.Lock()
	mock.calls.CreateTask = append(mock.calls.CreateTask, callInfo)
	mock.lockCreateTask.Unlock()
	if mock.CreateTaskFunc == nil {
		var (
			taskOut *model.Task
			errOut  error
		)
		return taskOut, errOut
	}
	return mock.CreateTaskFunc(ctx, task)
}

// CreateTaskCalls gets all the calls that were made to CreateTask.
// Check the length with:
//     len(mockedStorage.CreateTaskCalls())
func (mock *StorageMock) CreateTaskCalls() []struct {
	Ctx  context.Context
	Task *model.Task
} {
	var calls []struct {
		Ctx  context.Context
		Task *model.Task
	}
	mock.lockCreateTask.RLock()
	calls = mock.calls.CreateTask
	mock.lockCreateTask.RUnlock()
	return calls
}

// GetTask calls GetTaskFunc.
func (mock *StorageMock) GetTask(ctx context.Context, ID string) (*model.Task, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetTask.Lock()
	mock.calls.GetTask = append(mock.calls.GetTask, callInfo)
	mock.lockGetTask.Unlock()
	if mock.GetTaskFunc == nil {
		var (
			taskOut *model.Task
			errOut  error
		)
		return taskOut, errOut
	}
	return mock.GetTaskFunc(ctx, ID)
}

// GetTaskCalls gets all the calls that were made to GetTask.
// Check the length with:
//     len(mockedStorage.GetTaskCalls())
func (mock *StorageMock) GetTaskCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetTask.RLock()
	calls = mock.calls.GetTask
	mock.lockGetTask.RUnlock()
	return calls
}

// ListTask calls ListTaskFunc.
func (mock *StorageMock) ListTask(ctx context.Context, userID string, date time.Time, limit int, offset int) ([]*model.Task, error) {
	callInfo := struct {
		Ctx    context.Context
		UserID string
		Date   time.Time
		Limit  int
		Offset int
	}{
		Ctx:    ctx,
		UserID: userID,
		Date:   date,
		Limit:  limit,
		Offset: offset,
	}
	mock.lockListTask.Lock()
	mock.calls.ListTask = append(mock.calls.ListTask, callInfo)
	mock.lockListTask.Unlock()
	if mock.ListTaskFunc == nil {
		var (
			tasksOut []*model.Task
			errOut   error
		)
		return tasksOut, errOut
	}
	return mock.ListTaskFunc(ctx, userID, date, limit, offset)
}

// ListTaskCalls gets all the calls that were made to ListTask.
// Check the length with:
//     len(mockedStorage.ListTaskCalls())
func (mock *StorageMock) ListTaskCalls() []struct {
	Ctx    context.Context
	UserID string
	Date   time.Time
	Limit  int
	Offset int
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
		Date   time.Time
		Limit  int
		Offset int
	}
	mock.lockListTask.RLock()
	calls = mock.calls.ListTask
	mock.lockListTask.RUnlock()
	return calls
}
